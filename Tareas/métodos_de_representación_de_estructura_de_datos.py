# -*- coding: utf-8 -*-
"""Métodos de representación de estructura de datos

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RMzNxGzJv3OkV135qrRgpBRv81FPyr9E

**Métodos elo de representación de estructura de datos**

Nombre: Jose Manuel Aliaga Delgadillo

MÉTODO ESTÁTICO:

Ejemplo: información a cerca de un libro.
"""

"""
Library Catalog Program
Static data structure to store books information.
Features:
- Add new books
- Search books (by title, author, or ISBN)
- Display all books
"""
# Static data structure (dictionary)
library_catalog = {}

def add_book(title, author, isbn, genre):
    """
    Add a new book to the catalog.

    Args:
        title (str): Title of the book
        author (str): Author of the book
        isbn (str): ISBN of the book (unique key)
        genre (str): Genre of the book
    """
    if isbn in library_catalog:
        print("Book with this ISBN already exists.")
    else:
        library_catalog[isbn] = {
            "title": title,
            "author": author,
            "genre": genre
        }
        print(f'Book "{title}" added successfully.')

def search_book_by_title(title):
    """
    Search for books by title.

    Args:
        title (str): Title to search
    """
    results = [
        (isbn, data) for isbn, data in library_catalog.items()
        if data["title"].lower() == title.lower()
    ]

    if results:
        for isbn, data in results:
            print(f'ISBN: {isbn}, Title: {data["title"]}, '
                  f'Author: {data["author"]}, Genre: {data["genre"]}')
    else:
        print("No books found with that title.")

def search_book_by_author(author):
    """
    Search for books by author.

    Args:
        author (str): Author to search
    """
    results = [
        (isbn, data) for isbn, data in library_catalog.items()
        if data["author"].lower() == author.lower()
    ]

    if results:
        for isbn, data in results:
            print(f'ISBN: {isbn}, Title: {data["title"]}, '
                  f'Author: {data["author"]}, Genre: {data["genre"]}')
    else:
        print("No books found with that author.")

def search_book_by_isbn(isbn):
    """
    Search for a book by ISBN.

    Args:
        isbn (str): ISBN to search
    """
    if isbn in library_catalog:
        data = library_catalog[isbn]
        print(f'ISBN: {isbn}, Title: {data["title"]}, '
              f'Author: {data["author"]}, Genre: {data["genre"]}')
    else:
        print("No books found with that ISBN.")

def display_all_books():
    """
    Display all books in the catalog.
    """
    if not library_catalog:
        print("The library catalog is empty.")
    else:
        print("\n--- Library Catalog ---")
        for isbn, data in library_catalog.items():
            print(f'ISBN: {isbn}, Title: {data["title"]}, '
                  f'Author: {data["author"]}, Genre: {data["genre"]}')
        print("-----------------------\n")

if __name__ == "__main__":
    add_book("1984", "George Orwell", "12345", "Dystopian")
    add_book("To Kill a Mockingbird", "Harper Lee", "67890", "Fiction")
    add_book("The Hobbit", "J.R.R. Tolkien", "54321", "Fantasy")

    print("\nSearch by title:")
    search_book_by_title("1984")

    print("\nSearch by author:")
    search_book_by_author("Harper Lee")

    print("\nSearch by ISBN:")
    search_book_by_isbn("54321")

    print("\nDisplay all books:")
    display_all_books()

"""MÉTODO DINÁMICO:

Ejemplo: Historial de transacciones en un banco
"""

"""
Programa de Cuenta Bancaria
Estructura de datos dinámica (lista) para guardar transacciones.
Funciones:
- Depositar dinero
- Retirar dinero
- Ver historial de transacciones
- Consultar saldo
"""

# Estructura dinámica (lista)
historial_transacciones = []

def depositar(monto):
    """
    Depositar dinero y registrar la transacción.

    Args:
        monto (float): Monto a depositar
    """
    if monto <= 0:
        print("El monto del depósito debe ser mayor a cero.")
        return
    historial_transacciones.append({"tipo": "depósito", "monto": monto})
    print(f"Se depositó: ${monto:.2f}")

def retirar(monto):
    """
    Retirar dinero y registrar la transacción si el saldo lo permite.

    Args:
        monto (float): Monto a retirar
    """
    if monto <= 0:
        print("El monto del retiro debe ser mayor a cero.")
        return

    if monto > obtener_saldo():
        print("Fondos insuficientes.")
        return

    historial_transacciones.append({"tipo": "retiro", "monto": monto})
    print(f"Se retiró: ${monto:.2f}")

def ver_transacciones():
    """
    Mostrar todas las transacciones en orden cronológico.
    """
    if not historial_transacciones:
        print("No hay transacciones registradas.")
        return

    print("\n--- Historial de Transacciones ---")
    for i, transaccion in enumerate(historial_transacciones, start=1):
        print(f"{i}. {transaccion['tipo'].capitalize()} "
              f"- ${transaccion['monto']:.2f}")
    print("----------------------------------\n")

def obtener_saldo():
    """
    Calcular el saldo actual en base a todas las transacciones.

    Returns:
        float: Saldo actual
    """
    saldo = 0.0
    for transaccion in historial_transacciones:
        if transaccion["tipo"] == "depósito":
            saldo += transaccion["monto"]
        elif transaccion["tipo"] == "retiro":
            saldo -= transaccion["monto"]
    return saldo

# Ejemplo de uso
if __name__ == "__main__":
    depositar(500)
    retirar(200)
    depositar(150)
    retirar(600)  # Este debe fallar (fondos insuficientes)

    print("\nSaldo actual:")
    print(f"${obtener_saldo():.2f}")

    ver_transacciones()

"""MÉTODO PERSISTENTE:

Ejemplo: Lista de Tareas
"""

"""
Aplicación de Lista de Tareas
Almacena las tareas en un archivo JSON de forma persistente.
Funciones:
- Agregar tareas
- Marcar tareas como completadas
- Ver la lista de tareas
- Guardar y cargar desde archivo
"""

import json
import os

# Archivo donde se guardarán las tareas
ARCHIVO_TAREAS = "tareas.json"

# Lista dinámica de tareas
tareas = []

def cargar_tareas():
    """
    Cargar las tareas desde un archivo JSON.
    """
    global tareas
    if os.path.exists(ARCHIVO_TAREAS):
        with open(ARCHIVO_TAREAS, "r", encoding="utf-8") as archivo:
            tareas = json.load(archivo)
    else:
        tareas = []

def guardar_tareas():
    """
    Guardar las tareas en un archivo JSON.
    """
    with open(ARCHIVO_TAREAS, "w", encoding="utf-8") as archivo:
        json.dump(tareas, archivo, indent=4, ensure_ascii=False)

def agregar_tarea(descripcion):
    """
    Agregar una nueva tarea a la lista.

    Args:
        descripcion (str): Descripción de la tarea
    """
    tarea = {"descripcion": descripcion, "completada": False}
    tareas.append(tarea)
    guardar_tareas()
    print(f'Tarea agregada: "{descripcion}"')

def marcar_completada(indice):
    """
    Marcar una tarea como completada.

    Args:
        indice (int): Índice de la tarea en la lista (comienza en 1)
    """
    if 1 <= indice <= len(tareas):
        tareas[indice - 1]["completada"] = True
        guardar_tareas()
        print(f'Tarea "{tareas[indice - 1]["descripcion"]}" marcada como completada.')
    else:
        print("Índice inválido.")

def ver_tareas():
    """
    Mostrar todas las tareas con su estado.
    """
    if not tareas:
        print("No hay tareas en la lista.")
        return

    print("\n--- Lista de Tareas ---")
    for i, tarea in enumerate(tareas, start=1):
        estado = "✔ Completada" if tarea["completada"] else "Pendiente"
        print(f"{i}. {tarea['descripcion']} - {estado}")
    print("------------------------\n")

if __name__ == "__main__":
    cargar_tareas()

    agregar_tarea("Estudiar para el examen")
    agregar_tarea("Comprar pan")
    agregar_tarea("Hacer ejercicio")

    ver_tareas()

    marcar_completada(2)

    ver_tareas()

"""MÉTODO SIMULADO

Ejemplo: Modelado de una intersección de tráfico
"""

"""
Simulación de Intersección de Tráfico
Modela semáforos y coches usando orientación a objetos.
Funciones:
- Crear coches con tiempos y direcciones aleatorias
- Controlar semáforos con intervalos regulares
- Mover coches según las señales de tráfico
- Mostrar la intersección en consola
"""

import random
import time

class Coche:
    """
    Representa un coche en la intersección.
    """

    def __init__(self, direccion, tiempo_llegada):
        """
        Inicializa un coche.

        Args:
            direccion (str): Dirección de llegada ("N", "S", "E", "O")
            tiempo_llegada (int): Tiempo en que el coche llega
        """
        self.direccion = direccion
        self.tiempo_llegada = tiempo_llegada

    def __str__(self):
        return f"Coche({self.direccion}, llegada={self.tiempo_llegada})"


class Semaforo:
    """
    Representa un semáforo que controla el tráfico.
    """

    def __init__(self, direccion, tiempo_verde=5, tiempo_rojo=5):
        """
        Inicializa un semáforo.

        Args:
            direccion (str): Dirección controlada ("N-S" o "E-O")
            tiempo_verde (int): Duración de la luz verde
            tiempo_rojo (int): Duración de la luz roja
        """
        self.direccion = direccion
        self.tiempo_verde = tiempo_verde
        self.tiempo_rojo = tiempo_rojo
        self.estado = "verde"  # Comienza en verde
        self.tiempo_restante = tiempo_verde

    def cambiar_estado(self):
        """
        Cambia el estado del semáforo.
        """
        if self.estado == "verde":
            self.estado = "rojo"
            self.tiempo_restante = self.tiempo_rojo
        else:
            self.estado = "verde"
            self.tiempo_restante = self.tiempo_verde

    def tic(self):
        """
        Avanza el tiempo del semáforo.
        """
        self.tiempo_restante -= 1
        if self.tiempo_restante <= 0:
            self.cambiar_estado()

class Interseccion:
    """
    Representa una intersección con semáforos y coches.
    """

    def __init__(self):
        self.semaforo_ns = Semaforo("N-S")
        self.semaforo_eo = Semaforo("E-O")
        self.coches = []

    def generar_coche(self, tiempo_actual):
        """
        Genera un coche aleatoriamente.

        Args:
            tiempo_actual (int): Tiempo de simulación
        """
        if random.random() < 0.4:  # 40% de probabilidad por ciclo
            direccion = random.choice(["N", "S", "E", "O"])
            coche = Coche(direccion, tiempo_actual)
            self.coches.append(coche)

    def mover_coches(self):
        """
        Mueve los coches si el semáforo lo permite.
        """
        coches_restantes = []
        for coche in self.coches:
            if coche.direccion in ["N", "S"] and self.semaforo_ns.estado == "verde":
                print(f"Coche desde {coche.direccion} CRUZA la intersección.")
            elif coche.direccion in ["E", "O"] and self.semaforo_eo.estado == "verde":
                print(f"Coche desde {coche.direccion} CRUZA la intersección.")
            else:
                coches_restantes.append(coche)
        self.coches = coches_restantes

    def mostrar_interseccion(self, tiempo_actual):
        """
        Muestra el estado de la intersección en consola.
        """
        print("\n=========================")
        print(f"Tiempo: {tiempo_actual}")
        print(f"Semáforo N-S: {self.semaforo_ns.estado.upper()} "
              f"({self.semaforo_ns.tiempo_restante}s)")
        print(f"Semáforo E-O: {self.semaforo_eo.estado.upper()} "
              f"({self.semaforo_eo.tiempo_restante}s)")
        print(f"Coches esperando: {len(self.coches)}")
        for coche in self.coches:
            print(f"   - {coche}")
        print("=========================\n")

    def simular(self, ciclos=20, pausa=1):
        """
        Ejecuta la simulación de la intersección.

        Args:
            ciclos (int): Número de ciclos de simulación
            pausa (int): Tiempo de espera entre ciclos (segundos)
        """
        for tiempo_actual in range(1, ciclos + 1):
            self.generar_coche(tiempo_actual)
            self.mover_coches()
            self.mostrar_interseccion(tiempo_actual)

            # Avanzar semáforos
            self.semaforo_ns.tic()
            self.semaforo_eo.tic()

            time.sleep(pausa)

if __name__ == "__main__":
    interseccion = Interseccion()
    interseccion.simular(ciclos=15, pausa=0.5)